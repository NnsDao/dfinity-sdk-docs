---
sidebar_position: 5
---

# 可变状态

Motoko 中的每个 actor 都可以使用，但可能永远不会直接共享内部可变状态。

稍后，我们讨论参与者之间的共享，参与者在其中发送和接收不可变数据，并且还处理彼此的外部入口点，作为可共享的功能。与那些可共享数据的情况不同，一个关键的 Motoko 设计不变性是可变数据对分配它的参与者保持内部（私有），并且永远不会远程共享。

在本章中，我们将继续使用最少的示例来展示如何引入（私有）actor 状态，并使用变异操作来随时间改变它。

在本地对象和类中，我们引入了本地对象的语法，以及一个counter带有单个可变变量的最小actor。在接下来的章节中，我们展示了一个具有相同行为的actors，将计数器变量间接暴露在关联的服务接口后面以便远程使用它。

### 不可变变量与可变变量


该var语法声明在声明块可变变量：

```
let text  : Text = "abc";
let num  : Nat = 30;

var pair : (Text, Nat) = (text, num);
var text2 : Text = text;
```

上面的声明列表声明了四个变量。前两个变量 (text和num) 是词法范围内的不可变变量。最后两个变量（pair和text2）是词法范围的可变变量。


### 分配给可变内存

可变变量允许赋值，而不可变变量则不允许。

如果我们尝试为任何一个text或num以上分配新值，我们将得到静态类型错误；这些变量是不可变的。

但是，我们可以自由地更新可变变量的值pair 并text2使用赋值语法，写成 := ，如下所示：

```
text2 := text2 # "xyz";
pair := (text2, pair.1);
pair
```

上面，我们基于对每个变量的当前值应用一个简单的 "更新规则 "来更新它们（例如，我们通过将字符串常数 "xyz "附加到它的后缀来更新text2）。同样地，一个角色通过对其内部（私有）可变异变量进行更新来处理一些调用，使用的赋值语法与上述相同。

### 特殊的赋值操作

赋值操作 := 是通用的，对所有类型都有效。

Motoko还包括特殊的赋值操作，将赋值与二进制操作相结合。赋值使用对给定操作数的二进制操作和被赋值变量的当前内容。

例如，数字允许赋值和加法的结合:

```
var num2 = 2;
num2 += 40;
num2
```

在第二行之后，变量num2的值是42，正如人们所期望的那样。

Motoko也包括其他组合。例如，我们可以把上面更新text2的那一行更简洁地改写为：

```
text2 #= "xyz";
text2
```

与+=一样，这种组合形式避免了在（特殊）赋值运算符#=的右侧重复被赋值变量的名称。

赋值操作的完整列表列出了对适当类型（分别为数字、布尔值和文本值）的数字、逻辑和文本操作。

### 从易变的内存中读出

当我们更新每个变量时，我们也首先从可变内容中读取，没有特殊的语法。

这说明了一个微妙的问题。每一次使用一个易变的变量看起来就像使用一个不可变的变量，但并不像一个变量那样行事。事实上，它的含义更加复杂。正如许多语言（JavaScript、Java、C#等），但不是所有语言，每次使用的语法都隐藏了访问该变量标识的内存单元的内存效果，并获得其当前值。其他来自函数式传统的语言（SML、OCaml、Haskell等），一般会在语法上暴露这些效果。

下面，我们将详细探讨这一点。

### 了解 var 与 let 绑定的变量

TODOTODO
