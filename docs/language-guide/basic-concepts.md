---
sidebar_position: 4
---

# 基本概念和术语

Motoko 是为带有行为体(actor)的分布式编程而设计的。

在开始使用 actor 编写分布式处理程序之前，您应该熟悉任何编程语言的一些基本构建块，尤其是 Motoko。为了帮助您入门，本节介绍了以下在本文档的其余部分中使用的关键概念和术语，这些概念和术语对于学习 Motoko 编程至关重要：


+ program(程序)

+ declaration(聲明)

+ expression(表达式)

+ value(值)

+ variable(多变的)

+ type(类型)


如果你有用其他语言编程的经验，或者熟悉现代编程语言理论，你可能已经对这些术语和它们的使用方法感到熟悉。这些术语在Motoko中的使用方式并没有什么特别之处。然而，如果你是编程新手，本指南将逐步介绍这些术语，并使用简化的示例程序，避免使用错误的行为体(actors)或分布式编程。当你有了基本的术语作为基础，你就可以探索语言的更多高级方面。更高级的功能将通过相应的更复杂的例子来说明。

本节涵盖了以下主题:

Motoko程序的语法

打印数字和文本，并使用基础库

声明与表达式

变量的定义域范围

值和评估

变量的类型注释

类型健全性和类型安全的评估

### Motoko程序的语法

每个Motoko程序都是声明和表达式的自由组合，它们的语法类别是不同的，但又是相关的（关于精确的程序语法，请参见语言快速参考指南）。

对于我们在互联网计算机上部署的程序，一个有效的程序由一个actor表达式组成，用特定的语法（关键字actor）介绍，我们在actors和async数据中讨论。

在为该讨论做准备时，我们在本章和Mutable state中讨论了一些程序，这些程序并不是为了成为互联网计算机服务。相反，这些程序代码说明了用于编写这些服务的Motoko片段，并且每个程序都可以（通常）作为一个（非服务）Motoko程序单独运行，可能还有一些打印的终端输出。

本节中的例子使用简单的表达式来说明基本原理，例如数字计算。关于Motoko的全部表达式语法的概述，请参见Lanaguage快速参考。

作为一个起点，下面的代码片断包括两个声明--变量x和y--后面是一个表达式，形成一个单一的程序。

```
let x = 1;
let y = x + 1;
x * y + x
```


我们将在下面的讨论中使用这个程序代码的变化。

首先，这个程序的类型是Nat（自然数），当运行时，它的评估结果是（自然数）3的值。

引入一个带括号的块（do { and }）和另一个变量（z），我们可以将原程序修改如下:

```
let z = do {
  let x = 1;
  let y = x + 1;
  x * y + x
};

```

### 声明和表达式

声明介绍了不可变的变量、可变的状态、行为体(actor)、对象、类和其他类型。表达式描述了涉及这些概念的计算。

现在，我们使用声明不可变的变量和计算简单数学的例子程序。

声明与表达式
回顾一下，每个Motoko程序都是声明和表达式的自由组合，它们的句法类别是不同的，但又是相关的。在这一节中，我们用例子来说明它们的区别并适应它们的混合。

回想一下我们的例子程序，首先在上面介绍:

```
let x = 1;
let y = x + 1;
x * y + x;

```

实际上，这个程序是一个声明列表，由三个声明组成。

不可变的变量x，通过声明let x = 1;。

不可变的变量y，通过声明let y = x + 1;。

和一个未命名的隐式变量，用来保存最终表达式的值，x * y + x。

这个表达式x * y + x说明了一个更普遍的原则："每个表达式在必要时都可以被认为是一个声明，因为语言用该表达式的结果值隐含地声明了一个未命名的变量。"

当表达式作为最终声明出现时，这个表达式可以有任何类型。这里，表达式x * y + x的类型是Nat。

没有出现在最后，而是出现在声明列表中的表达式必须具有 unit type()类型。

**忽略声明列表中的非单位类型的表达式**

我们总是可以通过明确使用ignore来忽略任何未使用的结果值来克服这个单位类型的限制。例如:

```
let x = 1;
ignore(x + 42);
let y = x + 1;
ignore(y * 42);
x * y + x;
```


### 声明和变量替换

声明可以是相互递归的，但在不是相互递归的情况下，它们允许有一个替换语义。

回顾我们最初的例子:
```
let x = 1;
let y = x + 1;
x * y + x;
```

我们可以手动重写上面的程序，将变量的声明值替换为它们各自出现的值。

这样一来，我们就产生了下面的表达式，这也是一个程序:

`1 * (1 + 1) + 1`

这也是一个有效的程序--类型相同，行为相同（结果值为3）--与原始程序相同。

我们也可以用一个块来形成一个单一的表达式。

**从声明到块表达式**

上面的许多程序都是由一列声明组成的，就像上面这个例子一样:

```
let x = 1;
let y = x + 1;
x * y + x
```

一个声明列表本身不是（立即）一个表达式，所以我们不能（立即）用它的最终值声明另一个变量（3）。

块状表达式。我们可以用匹配的大括号将这个声明列表括起来，形成一个块表达式。块只允许作为控制流表达式的子表达式，如if、循环、case等。在所有其他地方，我们用do { ... }来表示块表达式，以区分块和对象字面。例如，do {}是类型为（）的空块，而{}是类型为{}的空记录。


```
do {
  let x = 1;
  let y = x + 1;
  x * y + x
}
```

这也是一个程序，但其中声明的变量x和y被私下划入我们介绍的块级定义域中。

这种块级定义域的形式保留了声明列表的自主性和它对变量名称的选择。

**声明遵循定义域范围**

上面，我们看到嵌套块保留了每个单独的声明列表及其对变量名称的选择的自主性。语言理论家们把这种想法称为定义域范围（lexical scoping）。它意味着变量的作用域可以嵌套，但它们在嵌套的过程中不能相互干扰。

例如，下面这个（更大的、封闭的）程序的评估值是42，而不是2，因为最后一行出现的x和y是指最初的定义，而不是封闭块中后来的定义。
```
let x = 40; let y = 2;
ignore do {
  let x = 1;
  let y = x + 1;
  x * y + x
};
x + y
```

其他缺乏定义域范围的语言可能会给这个程序一个不同的含义。然而，现代语言普遍赞成定义域范围，也就是这里给出的意思。

除了数学上的清晰性之外，定义域范围的主要实际好处是安全，以及它在构建组合安全系统中的应用。具体来说，Motoko给出了非常强的组合属性。例如，将你的程序嵌套在一个你不信任的程序中，就不能任意地将你的变量出现与不同的含义重新关联。


### 值和评估

一旦一个Motoko表达式收到了程序的（单一）控制线程，它就会急切地进行评估，直到它减少到一个（结果）值。

在这样做的时候，它通常会把控制权传递给子表达式，以及在它放弃环境控制栈的控制权之前传递给子程序。

如果这个表达式从未达到一个值的形式，那么这个表达式就会无限期地进行评估。稍后我们将介绍递归函数和命令式控制流，它们都允许非终结。现在，我们只考虑产生值的终止程序。

在上面的材料中，我们着重于产生自然数的表达式。然而，作为一个更广泛的编程语言，我们在下面简要地总结了其他数值形式。

原始类型

Motoko允许以下的原始值形式:

布尔值（true和false）

整数（...，-2，-1，0，1，2，...）；有界和无界的变体。

自然数（0, 1, 2, ...）；有界和无界的变体。

文本值 --- 单一编码字符的字符串。

数字:默认情况下，整数和自然数是无界的，不会溢出。相反，它们所使用的表示方法会增长，以适应任何有限的数字。

由于实际的原因，Motoko也包括整数和自然数的有界类型，与默认版本不同。每个有界变量都有一个固定的宽度（8、16、32、64中的一个），并且每个变量都有可能发生 "溢出"。如果发生这种情况，它就是一个错误，会导致程序被捕获。在Motoko中没有未经检查的、未被捕获的溢出，除了在明确定义的情况下，对于明确的包装操作（在操作符中用%字符表示）。该语言提供了原始的内置程序来转换这些不同的数字表示法。

语言的快速参考包含一个完整的原始类型列表。

**非原始值**

在上述原始值和类型的基础上，该语言允许用户定义的类型，以及下列每一种非原始值形式和相关类型。

Tuples，包括单元值（"空元组"）。

Arrays,，包括不可变和可变的变体。

Objects，有命名的、无序的字段和方法

Variants，有命名的构造函数和可选的有效载荷值

Function values, 包括可共享的函数。

Async values, 也被称为promises 或 futures。

Error values ,捕捉携带异常和系统故障的有效拦截

我们在后面的章节中讨论这些形式的使用。关于原始值和非原始值的精确语言定义，请参见语言快速参考。


**单位类型与无效类型**

Motoko没有名为void的类型。在许多情况下，读者可能会因为使用Java或C++等语言而认为返回类型是 "void"，我们鼓励他们改用单位类型，写成（）。

在实际应用中，与void一样，单位值通常具有零表示成本。

与void类型不同，有一个单位值，但与void的返回值一样，单位值在内部不携带任何数值，因此，它总是携带零信息。

另一种数学方法是把单位值看作一个没有元素的元组--空元组（"零元组"）。只有一个值具有这些属性，所以它在数学上是唯一的，因此不需要在运行时表示。

**自然数**

这个类型的成员由通常的值组成---0，1，2，......----，但是，和数学一样，其成员没有被约束在一个特殊的最大值内。相反，这些值的运行时表示法可以容纳任意大小的数字，使其 "溢出"（几乎）不可能。几乎是因为它与程序内存耗尽是同一事件，在极端情况下，某些程序总是会发生这种情况）。

Motoko允许进行人们所期望的通常的算术操作。作为一个说明性的例子，考虑下面的程序:

`let x = 42 + (1 * 37) / 12: Nat`

该程序的计算结果为 45，也是 Nat 类型。

### TODOTODO


### 科普小知识

[有界函数 ](https://www.wikiwand.com/en/Bounded_function)
